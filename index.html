<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Animation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .title {
            color: #fff;
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 20px;
            text-align: center;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradientShift 3s ease-in-out infinite;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .neural-network {
            position: relative;
            width: 900px;
            height: 500px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .layer {
            position: absolute;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            height: 100%;
            padding: 50px 0;
        }

        .input-layer { left: 50px; }
        .hidden-layer1 { left: 250px; }
        .hidden-layer2 { left: 450px; }
        .output-layer { left: 650px; }

        .neuron {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 3px solid rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
            position: relative;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .neuron.active {
            background: linear-gradient(135deg, #ff6b6b 0%, #ffa726 100%);
            box-shadow: 0 0 25px rgba(255, 107, 107, 0.8);
            transform: scale(1.1);
        }

        .neuron.input {
            background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%);
        }

        .neuron.output {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .connection {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.1));
            transform-origin: left center;
            transition: all 0.3s ease;
        }

        .connection.active {
            background: linear-gradient(90deg, #ff6b6b, #ffa726);
            height: 3px;
            box-shadow: 0 0 10px rgba(255, 107, 107, 0.8);
        }

        .signal {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: radial-gradient(circle, #ff6b6b 0%, #ffa726 100%);
            box-shadow: 0 0 15px rgba(255, 107, 107, 1);
            opacity: 0;
            animation: signal-flow 2s ease-in-out;
        }

        @keyframes signal-flow {
            0% { opacity: 0; transform: scale(0.5); }
            20% { opacity: 1; transform: scale(1); }
            80% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0.5); }
        }

        .controls {
            margin-top: 30px;
            display: flex;
            gap: 15px;
        }

        .btn {
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        .btn:active {
            transform: translateY(0);
        }

        .info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            max-width: 300px;
        }

        .layer-label {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            font-weight: bold;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .neuron.pulse {
            animation: pulse 0.6s ease-in-out;
        }
    </style>
</head>
<body>
    <div class="title">Neural Network in Action</div>
    
    <div class="neural-network" id="network">
        <!-- Layers will be dynamically created -->
        <div class="info">
            <strong>How it works:</strong><br>
            Click "Send Signal" to see data flow through the network. 
            Each neuron processes information and passes it forward through weighted connections.
        </div>
    </div>

    <div class="controls">
        <button class="btn" onclick="sendSignal()">Send Signal</button>
        <button class="btn" onclick="continuousMode()">Continuous Mode</button>
        <button class="btn" onclick="stopContinuous()">Stop</button>
        <button class="btn" onclick="resetNetwork()">Reset</button>
    </div>

    <script>
        let isAnimating = false;
        let continuousInterval = null;
        let networkStructure = {
            input: 4,
            hidden1: 6,
            hidden2: 4,
            output: 2
        };

        class NeuralNetwork {
            constructor() {
                this.layers = [];
                this.connections = [];
                this.signals = [];
                this.init();
            }

            init() {
                this.createLayers();
                this.createConnections();
            }

            createLayers() {
                const network = document.getElementById('network');
                const layerPositions = [
                    { name: 'input', x: 50, count: networkStructure.input, class: 'input' },
                    { name: 'hidden1', x: 250, count: networkStructure.hidden1, class: 'hidden' },
                    { name: 'hidden2', x: 450, count: networkStructure.hidden2, class: 'hidden' },
                    { name: 'output', x: 650, count: networkStructure.output, class: 'output' }
                ];

                layerPositions.forEach(layerInfo => {
                    const layer = document.createElement('div');
                    layer.className = `layer ${layerInfo.name}-layer`;
                    layer.style.left = layerInfo.x + 'px';

                    const label = document.createElement('div');
                    label.className = 'layer-label';
                    label.textContent = layerInfo.name.charAt(0).toUpperCase() + layerInfo.name.slice(1);
                    layer.appendChild(label);

                    const neurons = [];
                    const spacing = 400 / (layerInfo.count + 1);

                    for (let i = 0; i < layerInfo.count; i++) {
                        const neuron = document.createElement('div');
                        neuron.className = `neuron ${layerInfo.class}`;
                        neuron.style.position = 'absolute';
                        neuron.style.top = (spacing * (i + 1) - 30) + 'px';
                        neuron.textContent = layerInfo.class === 'input' ? `I${i+1}` : 
                                           layerInfo.class === 'output' ? `O${i+1}` : `H${i+1}`;
                        
                        layer.appendChild(neuron);
                        neurons.push({
                            element: neuron,
                            x: layerInfo.x + 30,
                            y: spacing * (i + 1) + 20
                        });
                    }

                    this.layers.push(neurons);
                    network.appendChild(layer);
                });
            }

            createConnections() {
                const network = document.getElementById('network');

                for (let layerIndex = 0; layerIndex < this.layers.length - 1; layerIndex++) {
                    const currentLayer = this.layers[layerIndex];
                    const nextLayer = this.layers[layerIndex + 1];

                    currentLayer.forEach((neuron1, i) => {
                        nextLayer.forEach((neuron2, j) => {
                            const connection = document.createElement('div');
                            connection.className = 'connection';
                            
                            const dx = neuron2.x - neuron1.x;
                            const dy = neuron2.y - neuron1.y;
                            const length = Math.sqrt(dx * dx + dy * dy);
                            const angle = Math.atan2(dy, dx) * 180 / Math.PI;

                            connection.style.left = neuron1.x + 'px';
                            connection.style.top = neuron1.y + 'px';
                            connection.style.width = length + 'px';
                            connection.style.transform = `rotate(${angle}deg)`;
                            connection.style.zIndex = '1';

                            network.appendChild(connection);
                            this.connections.push({
                                element: connection,
                                from: neuron1,
                                to: neuron2,
                                fromLayer: layerIndex,
                                toLayer: layerIndex + 1
                            });
                        });
                    });
                }
            }

            async sendSignal() {
                if (isAnimating) return;
                isAnimating = true;

                // Reset all neurons and connections
                this.resetVisualState();

                // Activate input neurons
                this.layers[0].forEach(neuron => {
                    neuron.element.classList.add('active', 'pulse');
                    setTimeout(() => neuron.element.classList.remove('pulse'), 600);
                });

                // Process through each layer
                for (let layerIndex = 0; layerIndex < this.layers.length - 1; layerIndex++) {
                    await this.processLayer(layerIndex);
                }

                setTimeout(() => {
                    isAnimating = false;
                    this.resetVisualState();
                }, 1000);
            }

            async processLayer(layerIndex) {
                const currentLayer = this.layers[layerIndex];
                const nextLayer = this.layers[layerIndex + 1];

                // Create signals from current layer to next layer
                const signalPromises = [];

                currentLayer.forEach((fromNeuron, i) => {
                    nextLayer.forEach((toNeuron, j) => {
                        const connectionIndex = i * nextLayer.length + j;
                        const connection = this.connections.filter(conn => 
                            conn.fromLayer === layerIndex && 
                            conn.from === fromNeuron && 
                            conn.to === toNeuron
                        )[0];

                        if (connection) {
                            signalPromises.push(this.createSignal(connection));
                        }
                    });
                });

                await Promise.all(signalPromises);

                // Activate next layer neurons
                await new Promise(resolve => {
                    setTimeout(() => {
                        nextLayer.forEach(neuron => {
                            neuron.element.classList.add('active', 'pulse');
                            setTimeout(() => neuron.element.classList.remove('pulse'), 600);
                        });
                        resolve();
                    }, 100);
                });

                await new Promise(resolve => setTimeout(resolve, 500));
            }

            createSignal(connection) {
                return new Promise((resolve) => {
                    const signal = document.createElement('div');
                    signal.className = 'signal';
                    
                    const network = document.getElementById('network');
                    network.appendChild(signal);

                    connection.element.classList.add('active');

                    const dx = connection.to.x - connection.from.x;
                    const dy = connection.to.y - connection.from.y;

                    signal.style.left = connection.from.x + 'px';
                    signal.style.top = connection.from.y + 'px';
                    signal.style.zIndex = '10';

                    // Animate signal movement
                    signal.style.animation = 'signal-flow 1s ease-in-out forwards';
                    
                    const keyframes = [
                        { 
                            transform: 'translate(0, 0) scale(0.5)', 
                            opacity: 0 
                        },
                        { 
                            transform: 'translate(0, 0) scale(1)', 
                            opacity: 1,
                            offset: 0.2
                        },
                        { 
                            transform: `translate(${dx}px, ${dy}px) scale(1)`, 
                            opacity: 1,
                            offset: 0.8
                        },
                        { 
                            transform: `translate(${dx}px, ${dy}px) scale(0.5)`, 
                            opacity: 0 
                        }
                    ];

                    signal.animate(keyframes, {
                        duration: 1000,
                        easing: 'ease-in-out'
                    });

                    setTimeout(() => {
                        connection.element.classList.remove('active');
                        signal.remove();
                        resolve();
                    }, 1000);
                });
            }

            resetVisualState() {
                // Remove active states
                document.querySelectorAll('.neuron').forEach(neuron => {
                    neuron.classList.remove('active', 'pulse');
                });
                
                document.querySelectorAll('.connection').forEach(connection => {
                    connection.classList.remove('active');
                });

                // Remove any remaining signals
                document.querySelectorAll('.signal').forEach(signal => {
                    signal.remove();
                });
            }
        }

        // Initialize the neural network
        const neuralNet = new NeuralNetwork();

        // Control functions
        function sendSignal() {
            neuralNet.sendSignal();
        }

        function continuousMode() {
            if (continuousInterval) return;
            
            continuousInterval = setInterval(() => {
                if (!isAnimating) {
                    neuralNet.sendSignal();
                }
            }, 3000);
        }

        function stopContinuous() {
            if (continuousInterval) {
                clearInterval(continuousInterval);
                continuousInterval = null;
            }
        }

        function resetNetwork() {
            stopContinuous();
            neuralNet.resetVisualState();
            isAnimating = false;
        }

        // Auto-start with a demo
        setTimeout(() => {
            neuralNet.sendSignal();
        }, 1000);
    </script>
</body>
</html>
